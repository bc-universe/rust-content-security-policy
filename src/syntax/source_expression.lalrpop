use syntax::types;
use std::str::FromStr;

grammar;

// https://www.w3.org/TR/CSP/#framework-directive-source-list

pub SourceExpression: types::Source<'input> = {
  Scheme => types::Source::Scheme(<>),
  Host => types::Source::Host(<>),
  //NonceSource,
  //HashSource,
  "'self'" => types::Source::Self_,
  "'unsafe-inline'" => types::Source::UnsafeInline,
  "'unsafe-eval'" => types::Source::UnsafeEval,
  "'strict-dynamic'" => types::Source::StrictDynamic,
  "'unsafe-hashed-attributes'" => types::Source::UnsafeHashedAttributes,
};

pub AncestorSource: types::Ancestor<'input> = {
  Scheme => types::Ancestor::Scheme(<>),
  Host => types::Ancestor::Host(<>),
  "'self'" => types::Ancestor::Self_,
};

Scheme: &'input str = r"[a-zA-Z]([a-zA-Z]|[0-9]|\+|\-|\.)*:"
  => &<>[..<>.len()-1];

// Just as a reminder, this is not a regex for matching URLs.
// The CSP specification defines a URL-like representation for "host sources",
// but does not allow query strings (as in http://example.com?query=string),
// and allows bare domain names (as in example.com) and weird wildcard things.
Host: &'input str =
  r"([a-zA-Z]([a-zA-Z]|[0-9]|\+|\-|\.)*://)?(\*\.)?[a-zA-Z0-9\-_]+(\.[a-zA-Z0-9\-_]+)*(:\*|:[0-9]+)?(/([a-zA-Z0-9\-\._~]|%[0-9a-fA-F][0-9a-fA-F])*)*"
    => <>;
