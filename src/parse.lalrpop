use types;

grammar;

// https://www.w3.org/TR/CSP/#parse-serialized-policy
pub DirectiveSet: types::DirectiveSet<'input> = {
  "" => types::DirectiveSet::new(),
  Directive => types::DirectiveSet::with(<>),
  <Directive> ";" => types::DirectiveSet::with(<>),
  // Iterating backwards over the set is a simple way to implement the
  // "first-directive-wins" behavior that the spec mandates.
  <d:Directive> ";" <s:DirectiveSet> => {let mut s = s; s.add_directive(d); s},
};

// https://www.w3.org/TR/CSP/#csp-directives
pub Directive: types::Directive<'input> = {
  "child-src" <SourceExpressionList> => types::Directive::ChildSrc(<>),
  "connect-src" <SourceExpressionList> => types::Directive::ConnectSrc(<>),
  "default-src" <SourceExpressionList> => types::Directive::DefaultSrc(<>),
  "font-src" <SourceExpressionList> => types::Directive::FontSrc(<>),
  "frame-src" <SourceExpressionList> => types::Directive::FrameSrc(<>),
  "img-src" <SourceExpressionList> => types::Directive::ImgSrc(<>),
  "manifest-src" <SourceExpressionList> => types::Directive::ManifestSrc(<>),
  "media-src" <SourceExpressionList> => types::Directive::MediaSrc(<>),
  "object-src" <SourceExpressionList> => types::Directive::ObjectSrc(<>),
  "script-src" <SourceExpressionList> => types::Directive::ScriptSrc(<>),
  "style-src" <SourceExpressionList> => types::Directive::StyleSrc(<>),
  "worker-src" <SourceExpressionList> => types::Directive::WorkerSrc(<>),
  "base-uri" <SourceExpressionList> => types::Directive::BaseUri(<>),
  "plugin-types" <MediaTypeList> => types::Directive::PluginTypes(<>),
  "sandbox" Scheme* => types::Directive::Sandbox,
};

// https://www.w3.org/TR/CSP/#grammardef-serialized-source-list

pub SourceExpressionList: Vec<types::Source<'input>> = {
  <SourceExpression+>,
  "'none'" => Vec::new(),
};

// https://www.w3.org/TR/CSP/#framework-directive-source-list

pub SourceExpression: types::Source<'input> = {
  SchemeSource,
  KeywordSource,
};

SchemeSource: types::Source<'input> = <Scheme> ":" => types::Source::Scheme(<>);

KeywordSource: types::Source<'input> = {
  "'self'" => types::Source::Self_,
  "'unsafe-inline'" => types::Source::UnsafeInline,
  "'unsafe-eval'" => types::Source::UnsafeEval,
  "'strict-dynamic'" => types::Source::StrictDynamic,
  "'unsafe-hashed-attributes'" => types::Source::UnsafeHashedAttributes,
};

// https://tools.ietf.org/html/rfc3986#section-3.1

Scheme = r"[a-zA-Z]([a-zA-Z]|[0-9]|\+|\-|\.)*";

// https://www.w3.org/TR/CSP/#grammardef-media-type-list

MediaTypeList = MediaType+;
MediaType = r"[a-zA-Z]([a-zA-Z]|[0-9]|\+|\-|\.)+/[a-zA-Z]([a-zA-Z]|[0-9]|\+|\-|\.)+";
